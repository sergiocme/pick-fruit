<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pick Fruit</title>

  <style>
    html,
    body {
      width: 100vw;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
      margin: 0;
    }

    #screen {
      width: 400px;
      height: 400px;
      border: 10px solid #ccc;
      image-rendering: pixelated;
    }
  </style>
</head>
<body>
  <canvas id="screen" width="10" height="10"></canvas>

  <script>
    function createGame() {
      const screen = document.getElementById('screen');
      const context = screen.getContext('2d');

      const state = {
        players: {},
        fruits: {},
        fieldLimit: {
          topEdge: 0,
          rightEdge: 9,
          bottomEdge: 9,
          leftEdge: 0,
        },
      };

      function addPlayer({ id, positionX, positionY }) {
        state.players[id] = {
          positionX,
          positionY,
        };
      }

      function removePlayer({ id }) {
        delete state.players[id];
      }

      function addFruit({ id, positionX, positionY }) {
        state.fruits[id] = {
          positionX,
          positionY,
        };
      }

      function removeFruit({ id }) {
        delete state.fruits[id];
      }

      function clearScreen() {
        context.clearRect(0, 0, 10, 10);
      }

      function renderScreen() {
        clearScreen();

        for (const playerKey in state.players) {
          const player = state.players[playerKey];
          context.fillStyle = 'black';
          context.fillRect(player.positionX, player.positionY, 1, 1);
        }

        for (const fruitKey in state.fruits) {
          const fruit = state.fruits[fruitKey];
          context.fillStyle = 'green';
          context.fillRect(fruit.positionX, fruit.positionY, 1, 1);
        }

        requestAnimationFrame(renderScreen);
      }

      function clearInRect(position) {
        context.clearRect(position.positionX, position.positionY, 1, 1);
      }

      function checkFruitCollision() {
        for (const playerKey in state.players) {
          const player = state.players[playerKey];

          for (const fruitKey in state.fruits) {
            const fruit = state.fruits[fruitKey];

            if (fruit.positionX === player.positionX && fruit.positionY === player.positionY) {
              console.log('Fruit collision');
            }
          }
        }
      }

      function movimentValidator(updatedPlayer) {
        for (const limit in state.fieldLimit) {
          validX = updatedPlayer.positionX > -1 && updatedPlayer.positionX < 10 ? true : false;
          validY = updatedPlayer.positionY > -1 && updatedPlayer.positionY < 10 ? true : false;
        }

        return (validX && validY);
      }

      function movePlayer({ pressedKey }) {
        const player = state.players['player1'];
        const moves = {
          ArrowUp: {
            movement(player) {
              const updatedPlayer = {
                ...player,
                positionY: player.positionY - 1,
              };

              const validMove = movimentValidator(updatedPlayer)
              if (validMove) {
                clearInRect({
                  positionX: player.positionX,
                  positionY: player.positionY,
                });
                state.players['player1'] = updatedPlayer;
              }
            },
          },
          ArrowRight: {
            movement(player) {
              const updatedPlayer = {
                ...player,
                positionX: player.positionX + 1,
              };

              const validMove = movimentValidator(updatedPlayer)
              if (validMove) {
                clearInRect({
                  positionX: player.positionX,
                  positionY: player.positionY,
                });
                state.players['player1'] = updatedPlayer;
              }
            },
          },
          ArrowDown: {
            movement(player) {
              const updatedPlayer = {
                ...player,
                positionY: player.positionY + 1,
              };

              const validMove = movimentValidator(updatedPlayer)
              if (validMove) {
                clearInRect({
                  positionX: player.positionX,
                  positionY: player.positionY,
                });
                state.players['player1'] = updatedPlayer;
              }
            },
          },
          ArrowLeft: {
            movement(player) {
              const updatedPlayer = {
                ...player,
                positionX: player.positionX - 1,
              };

              const validMove = movimentValidator(updatedPlayer)
              if (validMove) {
                clearInRect({
                  positionX: player.positionX,
                  positionY: player.positionY,
                });
                state.players['player1'] = updatedPlayer;
              }
            },
          },
        };

        if (player && moves[pressedKey]) {
          moves[pressedKey].movement(player);
          checkFruitCollision();
        }
      }

      return {
        state,
        renderScreen,
        movePlayer,
        addPlayer,
        removePlayer,
        addFruit,
        removeFruit,
      };
    }

    function createInput() {
      const state = {
        observers: [],
      };

      function subcribe(observerFunction) {
        state.observers.push(observerFunction);
      }

      function notifyAll(command) {
        for (const observerFunction of state.observers) {
          observerFunction(command);
        }
      }

      document.addEventListener('keydown', handleKeydown);
      function handleKeydown(event) {
        notifyAll({
          pressedKey: event.key,
        });
      }

      return {
        subcribe,
      };
    }

    const game = createGame();
    const input = createInput();
    input.subcribe(game.movePlayer);

    game.renderScreen();
  </script>
</body>
</html>
